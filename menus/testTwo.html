<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue常⻅面试题 | 前端技术文档</title>
    <meta name="description" content="A VitePress site">
    <link rel="stylesheet" href="/blog/assets/style.1edba350.css">
    <link rel="modulepreload" href="/blog/assets/app.5bf900bc.js">
    <link rel="modulepreload" href="/blog/assets/menus_testTwo.md.68ebdeba.lean.js">
    
    <link rel="icon" href="./logo.png">
  <script id="check-dark-light">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-592f9b90><!--[--><!--]--><!--[--><span tabindex="-1" data-v-344c78dc></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-344c78dc> Skip to content </a><!--]--><!----><header class="VPNav" data-v-592f9b90 data-v-40c63656><div class="VPNavBar has-sidebar" data-v-40c63656 data-v-a3cff43d><div class="container" data-v-a3cff43d><div class="VPNavBarTitle has-sidebar" data-v-a3cff43d data-v-0bb26fda><a class="title" href="/blog/" data-v-0bb26fda><!--[--><!--]--><!--[--><img class="VPImage logo" src="/blog/./logo.png" alt data-v-d82d2205><!--]--><!--[-->📚<!--]--><!--[--><!--]--></a></div><div class="content" data-v-a3cff43d><!--[--><!--]--><!----><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-a3cff43d data-v-32f7fdf4><span id="main-nav-aria-label" class="visually-hidden" data-v-32f7fdf4>Main Navigation</span><!--[--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-32f7fdf4 data-v-b4c7065a><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-b4c7065a><span class="text" data-v-b4c7065a><!----> 📚 文档 <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-b4c7065a><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-b4c7065a><div class="VPMenu" data-v-b4c7065a data-v-689bad26><div class="items" data-v-689bad26><!--[--><!--[--><div class="VPMenuLink" data-v-689bad26 data-v-85f806f4><a class="VPLink link" href="/blog/jsTop/promise.html" data-v-85f806f4 data-v-01ddcd0a><!--[-->js高级部分<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-689bad26 data-v-85f806f4><a class="VPLink link" href="/blog/components/" data-v-85f806f4 data-v-01ddcd0a><!--[-->组件<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-689bad26 data-v-85f806f4><a class="VPLink link" href="/blog/menus/" data-v-85f806f4 data-v-01ddcd0a><!--[-->测试<!--]--><!----></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/blog/menus/testOne.html" data-v-32f7fdf4 data-v-7407a46c data-v-01ddcd0a><!--[-->🏹 面试题<!--]--><!----></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-32f7fdf4 data-v-b4c7065a><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-b4c7065a><span class="text" data-v-b4c7065a><!----> 相关链接 <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-b4c7065a><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-b4c7065a><div class="VPMenu" data-v-b4c7065a data-v-689bad26><div class="items" data-v-689bad26><!--[--><!--[--><div class="VPMenuLink" data-v-689bad26 data-v-85f806f4><a class="VPLink link" href="https://gulpjs.com/" target="_blank" rel="noreferrer" data-v-85f806f4 data-v-01ddcd0a><!--[-->🐞 Gulp<!--]--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" height="24px" viewbox="0 0 24 24" width="24px" class="icon" data-v-01ddcd0a><path d="M0 0h24v24H0V0z" fill="none"></path><path d="M9 5v2h6.59L4 18.59 5.41 20 17 8.41V15h2V5H9z"></path></svg></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-689bad26 data-v-85f806f4><a class="VPLink link" href="https://rollupjs.org/" target="_blank" rel="noreferrer" data-v-85f806f4 data-v-01ddcd0a><!--[-->🌽 Webpack<!--]--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" height="24px" viewbox="0 0 24 24" width="24px" class="icon" data-v-01ddcd0a><path d="M0 0h24v24H0V0z" fill="none"></path><path d="M9 5v2h6.59L4 18.59 5.41 20 17 8.41V15h2V5H9z"></path></svg></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><span class="VPLink VPNavBarMenuLink" data-v-32f7fdf4 data-v-7407a46c data-v-01ddcd0a><!--[-->Github<!--]--><!----></span><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-a3cff43d data-v-96048b65><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" aria-checked="false" data-v-96048b65 data-v-6ff33b73 data-v-7ae90884><span class="check" data-v-7ae90884><span class="icon" data-v-7ae90884><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-6ff33b73><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-6ff33b73><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-a3cff43d data-v-f5e15277 data-v-0c3f8acf><!--[--><a class="VPSocialLink" href="https://github.com/Qianduan17634415573" target="_blank" rel="noopener" data-v-0c3f8acf data-v-9b689696><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-a3cff43d data-v-70a6aaea data-v-b4c7065a><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-b4c7065a><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-b4c7065a><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-b4c7065a><div class="VPMenu" data-v-b4c7065a data-v-689bad26><!----><!--[--><!--[--><!----><div class="group" data-v-70a6aaea><div class="item appearance" data-v-70a6aaea><p class="label" data-v-70a6aaea>Appearance</p><div class="appearance-action" data-v-70a6aaea><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" aria-checked="false" data-v-70a6aaea data-v-6ff33b73 data-v-7ae90884><span class="check" data-v-7ae90884><span class="icon" data-v-7ae90884><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-6ff33b73><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-6ff33b73><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-70a6aaea><div class="item social-links" data-v-70a6aaea><div class="VPSocialLinks social-links-list" data-v-70a6aaea data-v-0c3f8acf><!--[--><a class="VPSocialLink" href="https://github.com/Qianduan17634415573" target="_blank" rel="noopener" data-v-0c3f8acf data-v-9b689696><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-a3cff43d data-v-b592b567><span class="container" data-v-b592b567><span class="top" data-v-b592b567></span><span class="middle" data-v-b592b567></span><span class="bottom" data-v-b592b567></span></span></button></div></div></div><!----></header><div class="VPLocalNav" data-v-592f9b90 data-v-343fde74><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-343fde74><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="menu-icon" data-v-343fde74><path d="M17,11H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,11,17,11z"></path><path d="M21,7H3C2.4,7,2,6.6,2,6s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,7,21,7z"></path><path d="M21,15H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,15,21,15z"></path><path d="M17,19H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,19,17,19z"></path></svg><span class="menu-text" data-v-343fde74>Menu</span></button><a class="top-link" href="#" data-v-343fde74> Return to top </a></div><aside class="VPSidebar" data-v-592f9b90 data-v-a36642e4><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-a36642e4><span class="visually-hidden" id="sidebar-aria-label" data-v-a36642e4> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-a36642e4><section class="VPSidebarGroup" data-v-a36642e4 data-v-c9dca47e><div class="title" data-v-c9dca47e><h2 class="title-text" data-v-c9dca47e>面试题</h2><div class="action" data-v-c9dca47e><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-c9dca47e><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-c9dca47e><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-c9dca47e><!--[--><!--[--><a class="VPLink link link" href="/blog/menus/testOne.html" style="padding-left:0px;" data-v-a3ddc283 data-v-01ddcd0a><!--[--><span class="link-text" data-v-a3ddc283>js高级面试题</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link active" href="/blog/menus/testTwo.html" style="padding-left:0px;" data-v-a3ddc283 data-v-01ddcd0a><!--[--><span class="link-text" data-v-a3ddc283>vue面试题</span><!--]--><!----></a><!----><!--]--><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-592f9b90 data-v-1a7586c3><div class="VPDoc has-sidebar has-aside" data-v-1a7586c3 data-v-998ff9da><div class="container" data-v-998ff9da><div class="aside" data-v-998ff9da><div class="aside-curtain" data-v-998ff9da></div><div class="aside-container" data-v-998ff9da><div class="aside-content" data-v-998ff9da><div class="VPDocAside" data-v-998ff9da data-v-236575d9><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" data-v-236575d9 data-v-8c55b561><div class="content" data-v-8c55b561><div class="outline-marker" data-v-8c55b561></div><div class="outline-title" data-v-8c55b561>On this page</div><nav aria-labelledby="doc-outline-aria-label" data-v-8c55b561><span class="visually-hidden" id="doc-outline-aria-label" data-v-8c55b561> Table of Contents for current page </span><ul class="root" data-v-8c55b561 data-v-608cdddf><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-236575d9></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-998ff9da><div class="content-container" data-v-998ff9da><!--[--><!--]--><main class="main" data-v-998ff9da><div style="position:relative;" class="vp-doc _blog_menus_testTwo" data-v-998ff9da><div><h1 id="vue常⻅面试题" tabindex="-1">Vue常⻅面试题 <a class="header-anchor" href="#vue常⻅面试题" aria-hidden="true">#</a></h1><h2 id="_1-vue基础" tabindex="-1">1. Vue基础 <a class="header-anchor" href="#_1-vue基础" aria-hidden="true">#</a></h2><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式 JavaScript框架。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">全称是Vue.js或者Vuejs；</span></span>
<span class="line"><span style="color:#A6ACCD;">它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型；</span></span>
<span class="line"><span style="color:#A6ACCD;">帮助你高效地开发用户界面，无论任务是简单还是复杂；</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h2 id="_1-1-vue-js-的特点" tabindex="-1">1.1 Vue.js 的特点 <a class="header-anchor" href="#_1-1-vue-js-的特点" aria-hidden="true">#</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">易用： Vuejs是一个渐进式的框架，相比于其它框架，它更简单，易学，上手快。</span></span>
<span class="line"><span style="color:#A6ACCD;">灵活： （渐进式）不断繁荣的生态系统，可以在一个库和一套完整框架之间自如伸缩。</span></span>
<span class="line"><span style="color:#A6ACCD;">高效： 20kB min+gzip 运行大小；超快虚拟 DOM；最省心的优化。</span></span>
<span class="line"><span style="color:#A6ACCD;">双向绑定：开发效率高。</span></span>
<span class="line"><span style="color:#A6ACCD;">基于组件的代码共享</span></span>
<span class="line"><span style="color:#A6ACCD;">Web项目工程化，增加可读性、可维护性</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h2 id="_1-2-什么是-mvvm" tabindex="-1">1.2 什么是 MVVM？ <a class="header-anchor" href="#_1-2-什么是-mvvm" aria-hidden="true">#</a></h2><h4 id="mvc和mvvm都是一种软件的体系结构" tabindex="-1">MVC和MVVM都是一种软件的体系结构 <a class="header-anchor" href="#mvc和mvvm都是一种软件的体系结构" aria-hidden="true">#</a></h4><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">MVC是Model – View –Controller的简称，是在前期被使用非常框架的架构模式，比如iOS、前</span></span>
<span class="line"><span style="color:#A6ACCD;">端；</span></span>
<span class="line"><span style="color:#A6ACCD;">MVVM是Model-View-ViewModel的简称，是目前非常流行的架构模式；</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>通常情况下，我们也经常称Vue是一个MVVM的框架。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">Vue官方其实有说明，Vue虽然并没有完全遵守MVVM的模型，但是整个设计是受到它的启发的。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h2 id="_1-3-说说你对-spa-单⻚面的理解-它的优缺点分别是什么" tabindex="-1">1.3 说说你对 SPA 单⻚面的理解，它的优缺点分别是什么？ <a class="header-anchor" href="#_1-3-说说你对-spa-单⻚面的理解-它的优缺点分别是什么" aria-hidden="true">#</a></h2><p>SPA（ single-page application ）仅在 Web ⻚面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦 ⻚面加载完成，SPA 不会因为用户的操作而进行⻚面的重新加载或跳转；取而代之的是利用路由机制实 现 HTML 内容的变换，UI 与用户的交互，避免⻚面的重新加载。</p><h4 id="优点" tabindex="-1">优点： <a class="header-anchor" href="#优点" aria-hidden="true">#</a></h4><h4 id="用户体验好、快-内容的改变不需要重新加载整个⻚面-避免了不必要的跳转和重复渲染" tabindex="-1">用户体验好、快，内容的改变不需要重新加载整个⻚面，避免了不必要的跳转和重复渲染； <a class="header-anchor" href="#用户体验好、快-内容的改变不需要重新加载整个⻚面-避免了不必要的跳转和重复渲染" aria-hidden="true">#</a></h4><h4 id="基于上面一点-spa-相对对服务器压力小" tabindex="-1">基于上面一点，SPA 相对对服务器压力小； <a class="header-anchor" href="#基于上面一点-spa-相对对服务器压力小" aria-hidden="true">#</a></h4><h4 id="前后端职责分离-架构清晰-前端进行交互逻辑-后端负责数据处理" tabindex="-1">前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理； <a class="header-anchor" href="#前后端职责分离-架构清晰-前端进行交互逻辑-后端负责数据处理" aria-hidden="true">#</a></h4><h4 id="缺点" tabindex="-1">缺点： <a class="header-anchor" href="#缺点" aria-hidden="true">#</a></h4><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">初次加载耗时多：为实现单⻚ Web 应用功能及显示效果，需要在加载⻚面的时候将 JavaScript、</span></span>
<span class="line"><span style="color:#A6ACCD;">CSS 统一加载，部分⻚面按需加载；</span></span>
<span class="line"><span style="color:#A6ACCD;">前进后退路由管理：由于单⻚应用在一个⻚面中显示所有的内容，所以不能使用浏览器的前进后退</span></span>
<span class="line"><span style="color:#A6ACCD;">功能，所有的⻚面切换需要自己建立堆栈管理；</span></span>
<span class="line"><span style="color:#A6ACCD;">SEO 难度较大：由于所有的内容都在一个⻚面中动态替换显示，所以在 SEO 上其有着天然的弱</span></span>
<span class="line"><span style="color:#A6ACCD;">势。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="_1-3-v-show-与-v-if-有什么区别" tabindex="-1">1.3 v-show 与 v-if 有什么区别？ <a class="header-anchor" href="#_1-3-v-show-与-v-if-有什么区别" aria-hidden="true">#</a></h3><h4 id="首先-在用法上的区别" tabindex="-1">首先，在用法上的区别： <a class="header-anchor" href="#首先-在用法上的区别" aria-hidden="true">#</a></h4><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">v-show是不支持template；</span></span>
<span class="line"><span style="color:#A6ACCD;">v-show不可以和v-else一起使用；</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>其次，本质的区别：</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">v-show元素无论是否需要显示到浏览器上，它的DOM实际都是有存在的，只是通过CSS的display</span></span>
<span class="line"><span style="color:#A6ACCD;">属性来进行切换；</span></span>
<span class="line"><span style="color:#A6ACCD;">v-if当条件为false时，其对应的原生压根不会被渲染到DOM中；</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>开发中如何进行选择呢？</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">如果我们的原生需要在显示和隐藏之间频繁的切换，那么使用v-show；</span></span>
<span class="line"><span style="color:#A6ACCD;"> 如果不会频繁的发生切换，那么使用v-if；</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="_1-4-数组中的哪些方法会触发视图的更新" tabindex="-1">1.4 数组中的哪些方法会触发视图的更新？ <a class="header-anchor" href="#_1-4-数组中的哪些方法会触发视图的更新" aria-hidden="true">#</a></h3><p>Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新，这些被包裹过的方法包 括：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">push()</span></span>
<span class="line"><span style="color:#A6ACCD;">pop()</span></span>
<span class="line"><span style="color:#A6ACCD;">shift()</span></span>
<span class="line"><span style="color:#A6ACCD;">unshift()</span></span>
<span class="line"><span style="color:#A6ACCD;">splice()</span></span>
<span class="line"><span style="color:#A6ACCD;">sort()</span></span>
<span class="line"><span style="color:#A6ACCD;">reverse()</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>上面的方法会直接修改原来的数组，所以它们会触发视图更新。</p><h4 id="其它数组的方法" tabindex="-1">其它数组的方法: <a class="header-anchor" href="#其它数组的方法" aria-hidden="true">#</a></h4><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">但是某些方法不会替换原来的数组，而是会生成新的数组，比如 filter()、concat() 和 slice()，使用</span></span>
<span class="line"><span style="color:#A6ACCD;">这些方法将不会触发视图更新。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="_1-5-vue中v-for的key-有什么作用" tabindex="-1">1.5 Vue中v-for的key 有什么作用？ <a class="header-anchor" href="#_1-5-vue中v-for的key-有什么作用" aria-hidden="true">#</a></h3><p>在使用v-for进行列表渲染时，我们通常会给元素或者组件绑定一个key属性。</p><p>这个key属性有什么作用呢？</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">key属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。</span></span>
<span class="line"><span style="color:#A6ACCD;">如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型</span></span>
<span class="line"><span style="color:#A6ACCD;">元素的算法</span></span>
<span class="line"><span style="color:#A6ACCD;">使用key时，它会基于key的变化重新排列元素顺序，并且会移除/销毁key不存在的元素。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>key 是 VNode 的唯一标记，通过这个 key， diff 操作可以更准确、更快速的达到复用节点，更新视图的 目的。复用节点就需要通过移动元素的位置来达到更新的目的。</p><h3 id="_1-6-computed和method有什么区别" tabindex="-1">1.6 computed和method有什么区别？ <a class="header-anchor" href="#_1-6-computed和method有什么区别" aria-hidden="true">#</a></h3><h4 id="计算属性和方法" tabindex="-1">计算属性和方法： <a class="header-anchor" href="#计算属性和方法" aria-hidden="true">#</a></h4><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">都可以通过this来访问</span></span>
<span class="line"><span style="color:#A6ACCD;">都可以对一些数据进行处理和计算</span></span>
<span class="line"><span style="color:#A6ACCD;">对于包含响应式数据计算的逻辑，应该使用计算属性，因为计算属性是有缓存。</span></span>
<span class="line"><span style="color:#A6ACCD;">computed和method的区别</span></span>
<span class="line"><span style="color:#A6ACCD;">computed底层会缓存, 性能更高</span></span>
<span class="line"><span style="color:#A6ACCD;">计算属性会基于它们的依赖关系进行缓存;</span></span>
<span class="line"><span style="color:#A6ACCD;">在数据不发生变化时，计算属性是不需要重新计算的</span></span>
<span class="line"><span style="color:#A6ACCD;">但是如果依赖的数据发生变化，在使用时，计算属性依然会重新进行计算</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="_1-7-什么是双向绑定-v-model的本质是什么" tabindex="-1">1.7 什么是双向绑定？v-model的本质是什么？ <a class="header-anchor" href="#_1-7-什么是双向绑定-v-model的本质是什么" aria-hidden="true">#</a></h3><h4 id="双向绑定" tabindex="-1">双向绑定: <a class="header-anchor" href="#双向绑定" aria-hidden="true">#</a></h4><h4 id="即当数据发生变化的时候-视图也就发生变化-当视图发生变化的时候-数据也会跟着同步变化" tabindex="-1">即当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化 <a class="header-anchor" href="#即当数据发生变化的时候-视图也就发生变化-当视图发生变化的时候-数据也会跟着同步变化" aria-hidden="true">#</a></h4><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">v-model 是语法糖，它负责监听用户在表单元素中的输入事件来更新数据</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>表单元素使用v-model的本质：</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">v-bind绑定value属性的值</span></span>
<span class="line"><span style="color:#A6ACCD;">v-on绑定input事件监听到函数,函数会获取最新的值赋值到绑定的属性中</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>组件使用v-model的本质：</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">将其 value attribute 绑定到一个名叫 modelValue 的 prop 上；</span></span>
<span class="line"><span style="color:#A6ACCD;">在其 input 事件被触发时，将新的值通过自定义的 update:modelValue 事件抛出(发出)；</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">&lt;input type=&quot;text&quot; :value=&quot;message&quot; @input=&quot;message = $event.target.value&quot; /&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="_1-8-data选项为什么是一个函数而不是对象" tabindex="-1">1.8 data选项为什么是一个函数而不是对象？ <a class="header-anchor" href="#_1-8-data选项为什么是一个函数而不是对象" aria-hidden="true">#</a></h3><p>JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行 操作，其他实例中的数据也会发生变化。</p><p>而在Vue中，我们更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相 互干扰。</p><p>所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义。</p><p>这样当我们每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空 间，它们各自维护自己的数据，不会干扰其他组件的正常运行。</p><h3 id="_1-9-vue-data-中某一个属性的值发生改变后-视图会立即同步执行" tabindex="-1">1.9 Vue data 中某一个属性的值发生改变后，视图会立即同步执行 <a class="header-anchor" href="#_1-9-vue-data-中某一个属性的值发生改变后-视图会立即同步执行" aria-hidden="true">#</a></h3><h3 id="重新渲染吗" tabindex="-1">重新渲染吗？ <a class="header-anchor" href="#重新渲染吗" aria-hidden="true">#</a></h3><h4 id="不会立即同步执行重新渲染。" tabindex="-1">不会立即同步执行重新渲染。 <a class="header-anchor" href="#不会立即同步执行重新渲染。" aria-hidden="true">#</a></h4><p>Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。</p><p>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循 环中发生的所有数据变更。</p><p>如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必 要的计算和 DOM 操作是非常重要的。</p><p>然后，在下一个的事件循环”tick”中，Vue 刷新队列并执行实际（已去重的）工作。</p><h3 id="_1-10-sass是什么-如何在vue中安装和使用" tabindex="-1">1.10 sass是什么？如何在vue中安装和使用？ <a class="header-anchor" href="#_1-10-sass是什么-如何在vue中安装和使用" aria-hidden="true">#</a></h3><p>sass是一种CSS预处理器语言，除此之外，less、stylus也是常⻅的CSS预处理器语言。</p><p>sass安装和使用步骤如下：</p><ol><li>用npm安装加载程序（ sass-loader、 css-loader等加载程序)。</li><li>在 webpack.config.js中配置sass加载程序。</li></ol><h3 id="_1-11-在-vue-js开发环境下调用api接口-如何避免跨域" tabindex="-1">1.11 在 Vue. js开发环境下调用API接口，如何避免跨域 <a class="header-anchor" href="#_1-11-在-vue-js开发环境下调用api接口-如何避免跨域" aria-hidden="true">#</a></h3><p>1.在vue.config.js中的devServer选项中的proxy中配置反向代理</p><p>2.在vite.config.js中的server选项中的proxy中配置反向代理</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">&lt;Counter v-model=&quot;appCounter&quot;/&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;!-- 相当于--&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;Counter v-bind:modelValue=&quot;appCounter&quot; @update:modelValue=&quot;appCounter =</span></span>
<span class="line"><span style="color:#A6ACCD;">$event&quot;/&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>3.直接后端开发人员配置cors</p><h3 id="_1-12-v-if和v-for一起使用的弊端及解决办法" tabindex="-1">1.12 v-if和v-for一起使用的弊端及解决办法 <a class="header-anchor" href="#_1-12-v-if和v-for一起使用的弊端及解决办法" aria-hidden="true">#</a></h3><p>Vue.js 中使用最多的两个指令就是 v-if 和 v-for，因此开发者们可能会想要同时使用它们。虽然不 建议这样做，但有时确实是必须的，于是我们想提供有关其工作方式的指南。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">2..x 版本中在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用。</span></span>
<span class="line"><span style="color:#A6ACCD;">3.x 版本中 v-if 总是优先于 v-for 生效。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>由于语法上存在歧义，建议避免在同一元素上同时使用两者。</p><p>比起在模板层面管理相关逻辑，更好的办法是通过创建计算属性筛选出列表，并以此创建可⻅元素，比 如：</p><ol><li>在v-for的外层或内层包裹一个元素（template）来使用v-if</li><li>用computed处理筛选出列表</li></ol><h3 id="_1-13-谈谈你对-keep-alive-的了解" tabindex="-1">1.13 谈谈你对 keep-alive 的了解？ <a class="header-anchor" href="#_1-13-谈谈你对-keep-alive-的了解" aria-hidden="true">#</a></h3><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">一般结合路由和动态组件一起使用，用于缓存组件。</span></span>
<span class="line"><span style="color:#A6ACCD;">提供 include 和 exclude 属性，两者都支持字符串或正则表达式。</span></span>
<span class="line"><span style="color:#A6ACCD;">include 表示只有名称匹配的组件会被缓存。</span></span>
<span class="line"><span style="color:#A6ACCD;">exclude 表示任何名称匹配的组件都不会被缓存。</span></span>
<span class="line"><span style="color:#A6ACCD;">其中 exclude 的优先级比 include 高。</span></span>
<span class="line"><span style="color:#A6ACCD;">对应两个钩子函数 activated 和 deactivated 。</span></span>
<span class="line"><span style="color:#A6ACCD;">当组件被激活时，触发钩子函数 activated。</span></span>
<span class="line"><span style="color:#A6ACCD;">当组件被移除时，触发钩子函数 deactivated。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="_1-14-说说vue插槽的作用和平时开发中的应用" tabindex="-1">1.14 说说Vue插槽的作用和平时开发中的应用？ <a class="header-anchor" href="#_1-14-说说vue插槽的作用和平时开发中的应用" aria-hidden="true">#</a></h3><h4 id="插槽的作用" tabindex="-1">插槽的作用: <a class="header-anchor" href="#插槽的作用" aria-hidden="true">#</a></h4><h4 id="支持在父组件自定义子组件中的个内容" tabindex="-1">支持在父组件自定义子组件中的个内容 <a class="header-anchor" href="#支持在父组件自定义子组件中的个内容" aria-hidden="true">#</a></h4><h4 id="让子组件更具有通用性-不必限定死某个内容" tabindex="-1">让子组件更具有通用性，不必限定死某个内容 <a class="header-anchor" href="#让子组件更具有通用性-不必限定死某个内容" aria-hidden="true">#</a></h4><h4 id="插槽平时开发中的应用" tabindex="-1">插槽平时开发中的应用: <a class="header-anchor" href="#插槽平时开发中的应用" aria-hidden="true">#</a></h4><h4 id="在封装组件时-如果组件中的某个内容是动态的或不确定的-就可以使用插槽来代替了。" tabindex="-1">在封装组件时，如果组件中的某个内容是动态的或不确定的，就可以使用插槽来代替了。 <a class="header-anchor" href="#在封装组件时-如果组件中的某个内容是动态的或不确定的-就可以使用插槽来代替了。" aria-hidden="true">#</a></h4><h4 id="在使用第三方库时-往往会通过使用插槽类自定义第三方组件中的某些内容。" tabindex="-1">在使用第三方库时，往往会通过使用插槽类自定义第三方组件中的某些内容。 <a class="header-anchor" href="#在使用第三方库时-往往会通过使用插槽类自定义第三方组件中的某些内容。" aria-hidden="true">#</a></h4><h2 id="_2-component组件" tabindex="-1">2. Component组件 <a class="header-anchor" href="#_2-component组件" aria-hidden="true">#</a></h2><h3 id="_2-1-父子组件的生命周期顺序" tabindex="-1">2.1 父子组件的生命周期顺序 <a class="header-anchor" href="#_2-1-父子组件的生命周期顺序" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">加载渲染过程： 父beforeCreate -&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子</span></span>
<span class="line"><span style="color:#A6ACCD;">created -&gt; 子beforeMount -&gt;子mounted -&gt; 父mounted</span></span>
<span class="line"><span style="color:#A6ACCD;">子组件更新过程：父beforeUpdate -&gt; 子beforeUpdate -&gt; 子updated -&gt; 父updated</span></span>
<span class="line"><span style="color:#A6ACCD;">父组件更新过程：父beforeUpdate -&gt; 父updated</span></span>
<span class="line"><span style="color:#A6ACCD;">销毁过程：父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="_2-2-组件通讯-传值-式有哪些" tabindex="-1">2.2 组件通讯(传值)式有哪些? <a class="header-anchor" href="#_2-2-组件通讯-传值-式有哪些" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">父传子：子组件通过props来接收父组件传递的属性 xxx 的值</span></span>
<span class="line"><span style="color:#A6ACCD;">子传父：子组件通过emit触发事件传递，父组件通过监听对应的事件来接收数据</span></span>
<span class="line"><span style="color:#A6ACCD;">Provide/Inject：父组件提供内容，子或孙组件可以注入父组件提供的内容。</span></span>
<span class="line"><span style="color:#A6ACCD;">组件实例：通过ref来拿到组件的实例，调用实例的属性或方法进行传值。</span></span>
<span class="line"><span style="color:#A6ACCD;">事件总线：可以自己编写EventBus插件来进行通讯，或世界使用第三方的事件总线库。</span></span>
<span class="line"><span style="color:#A6ACCD;">用Vuex/Pinia: 可以使用全局状态管理来进行全局共享数据。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="_2-3-什么是生命周期函数-vue组件的生命周期函数有哪些" tabindex="-1">2.3 什么是生命周期函数？Vue组件的生命周期函数有哪些？ <a class="header-anchor" href="#_2-3-什么是生命周期函数-vue组件的生命周期函数有哪些" aria-hidden="true">#</a></h3><h4 id="生命周期函数" tabindex="-1">生命周期函数： <a class="header-anchor" href="#生命周期函数" aria-hidden="true">#</a></h4><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">生命周期函数是一些钩子函数（回调函数），在某个时间会被Vue源码内部进行回调</span></span>
<span class="line"><span style="color:#A6ACCD;">通过对生命周期函数的回调，我们可以知道目前组件正在经历什么阶段</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>Vue2的生命周期函数:</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">beforeCreate :组件实例在创建之前</span></span>
<span class="line"><span style="color:#A6ACCD;">created: 组件被创建完成</span></span>
<span class="line"><span style="color:#A6ACCD;">可以发送网络请求</span></span>
<span class="line"><span style="color:#A6ACCD;">可以事件监听</span></span>
<span class="line"><span style="color:#A6ACCD;">this.$watch()</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">beforeMount : 组件template准备被挂载</span></span>
<span class="line"><span style="color:#A6ACCD;">mounted :组件template已经被挂载</span></span>
<span class="line"><span style="color:#A6ACCD;">可以获取DOM,可以使用DOM</span></span>
<span class="line"><span style="color:#A6ACCD;">beforeUpdate: 准备更新DOM</span></span>
<span class="line"><span style="color:#A6ACCD;">updated: 更新DOM,根据最新数据生成新的VNode,生成新的虚拟DOM,转换为真实的DOM</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">beforeUnmount: 卸载之前</span></span>
<span class="line"><span style="color:#A6ACCD;">unmounted: DOM 元素被卸载完成</span></span>
<span class="line"><span style="color:#A6ACCD;">回收操作(取消事件监听)</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>Vue3的生命周期函数:</strong></p><h2 id="_3-composition-api" tabindex="-1">3. Composition API <a class="header-anchor" href="#_3-composition-api" aria-hidden="true">#</a></h2><h3 id="_3-1-什么是composition-api-和-options-api" tabindex="-1">3.1 什么是Composition API 和 Options API？ <a class="header-anchor" href="#_3-1-什么是composition-api-和-options-api" aria-hidden="true">#</a></h3><p>Composition API:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">Composition API 是一组 API，允许我们使用导入的函数而不是声明选项来编写 Vue 组件。它是一</span></span>
<span class="line"><span style="color:#A6ACCD;">个涵盖以下 API 的总称：Reactivity API、Lifecycle Hooks、Dependency Injection等等</span></span>
<span class="line"><span style="color:#A6ACCD;">使用Composition API编写组件时可以根据逻辑功能来组织代码。比如可以把一个功能所用到的</span></span>
<span class="line"><span style="color:#A6ACCD;">API 放在一起，这样可以让代码高内聚和低耦合，进而提高了代码的逻辑的复用性。</span></span>
<span class="line"><span style="color:#A6ACCD;">在 Vue 3 中，它也主要与script setup语法一起使用。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>Options API:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">在对应的属性中编写对应的功能模块, 比如data定义数据、methods中定义方法、computed中定</span></span>
<span class="line"><span style="color:#A6ACCD;">义计算属性、watch中监听属性改变，也包括生命周期钩子</span></span>
<span class="line"><span style="color:#A6ACCD;">弊端: 当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中,当组件变得复</span></span>
<span class="line"><span style="color:#A6ACCD;">杂，导致对应属性的列表也会增⻓，这可能会导致组件难以阅读和理解</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="_3-2-composition-api和之options-api有什么区别" tabindex="-1">3.2 Composition API和之Options API有什么区别? <a class="header-anchor" href="#_3-2-composition-api和之options-api有什么区别" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">在逻辑组织和逻辑复用方面，Composition API是优于Options API。</span></span>
<span class="line"><span style="color:#A6ACCD;">Composition API几乎是函数，会有更好的类型推断，对于TS的支持更友好。</span></span>
<span class="line"><span style="color:#A6ACCD;">Composition API对 tree-shaking 友好，代码也更容易压缩。</span></span>
<span class="line"><span style="color:#A6ACCD;">Composition API中⻅不到this的使用，减少了this指向不明的情况。</span></span>
<span class="line"><span style="color:#A6ACCD;">Composition API用起来稍微复杂一点，而Options API就非常简单、易于使用。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="_3-3-说说vue3中setup函数的作用" tabindex="-1">3.3 说说Vue3中setup函数的作用？ <a class="header-anchor" href="#_3-3-说说vue3中setup函数的作用" aria-hidden="true">#</a></h3><p>在Vue3中，setup()函数充当了组件编写Composition API 的入口点。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">setup函数参数主要有两个参数：</span></span>
<span class="line"><span style="color:#A6ACCD;">第一个参数：props , 父组件传递过来的属性会被放到props对象中</span></span>
<span class="line"><span style="color:#A6ACCD;">第二个参数：context, 它里面包含三个属性</span></span>
<span class="line"><span style="color:#A6ACCD;">attrs：所有的非prop的attribute；</span></span>
<span class="line"><span style="color:#A6ACCD;">slots：父组件传递过来的插槽；</span></span>
<span class="line"><span style="color:#A6ACCD;">emit：当我们组件内部需要发出事件时会用到emit（因为我们不能访问this，所以不可</span></span>
<span class="line"><span style="color:#A6ACCD;">以通过 this.$emit发出事件）</span></span>
<span class="line"><span style="color:#A6ACCD;">可以在setup中可以定义响应式数据、方法、计算属性、侦听器等等。</span></span>
<span class="line"><span style="color:#A6ACCD;">可以通过setup的返回值来替代data选项，让数据可以直接在template中使用。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="_3-4-ref和reactive有什么区别-开发中如何选择" tabindex="-1">3.4 ref和reactive有什么区别？开发中如何选择？ <a class="header-anchor" href="#_3-4-ref和reactive有什么区别-开发中如何选择" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">ref和reactive都是响应式的API，都可以用来定义响应式的数据。</span></span>
<span class="line"><span style="color:#A6ACCD;">ref可以包裹任意数据类型，reactive只能包裹复杂数据类型，比如对象、数组。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">ref返回一个ref对象，在script中取值需要通过value属性，但是在模板中使用会进行解包不需要调</span></span>
<span class="line"><span style="color:#A6ACCD;">用value。</span></span>
<span class="line"><span style="color:#A6ACCD;">reactive包裹的是复杂数据类型，直接取里面的属性即可。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">ref几乎可以应用在任何场景，而且包含reactive适合的场景</span></span>
<span class="line"><span style="color:#A6ACCD;">reactive的应用场景比较受限，第一：值比较固定，第二：值与值之间是有联系的。</span></span>
<span class="line"><span style="color:#A6ACCD;">开发中尽量选择ref</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="_3-5-composition-api常⻅的几个函数与用法" tabindex="-1">3.5 Composition API常⻅的几个函数与用法？ <a class="header-anchor" href="#_3-5-composition-api常⻅的几个函数与用法" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">ref</span></span>
<span class="line"><span style="color:#A6ACCD;">包裹任意类型的值，将包裹的值加入响应式</span></span>
<span class="line"><span style="color:#A6ACCD;">reactive</span></span>
<span class="line"><span style="color:#A6ACCD;">包裹复杂类型的值，将包裹的值加入响应式</span></span>
<span class="line"><span style="color:#A6ACCD;">computed</span></span>
<span class="line"><span style="color:#A6ACCD;">把一些复杂逻辑用computed进行包裹，如同Options API中的计算属性一样</span></span>
<span class="line"><span style="color:#A6ACCD;">computed会自动收集相关依赖，当依赖发生变化时，会自动进行更新</span></span>
<span class="line"><span style="color:#A6ACCD;">生命周期</span></span>
<span class="line"><span style="color:#A6ACCD;">Vue3中想要在beforeCreate和created中做的事，直接在setup中做即可</span></span>
<span class="line"><span style="color:#A6ACCD;">Vue3的其他的生命周期函数都要在前面加一个on，然后需要在vue中主动引入</span></span>
<span class="line"><span style="color:#A6ACCD;">watch</span></span>
<span class="line"><span style="color:#A6ACCD;">watch可以监听单个数据源，也可以监听多个数据源</span></span>
<span class="line"><span style="color:#A6ACCD;">watch是懒执行，第一次是不会执行的，除非你为其提供第三个参数中的immediate属性为</span></span>
<span class="line"><span style="color:#A6ACCD;">true</span></span>
<span class="line"><span style="color:#A6ACCD;">watch只有等到监听的数据源发生了变化后，才会执行第二个参数（回调）</span></span>
<span class="line"><span style="color:#A6ACCD;">watch可以获取监听数据源的前后变化的值</span></span>
<span class="line"><span style="color:#A6ACCD;">侦听多个数据源的时候，第一个参数是数组类型</span></span>
<span class="line"><span style="color:#A6ACCD;">watchEffect</span></span>
<span class="line"><span style="color:#A6ACCD;">watchEffect会自动收集依赖，收集的依赖是第一个参数，也就是回调函数中有哪些东⻄是加</span></span>
<span class="line"><span style="color:#A6ACCD;">入响应式的</span></span>
<span class="line"><span style="color:#A6ACCD;">如果这个值加入了响应式就会被收集起来，当被收集的值发生了变化，就会重新执行这个回</span></span>
<span class="line"><span style="color:#A6ACCD;">调函数</span></span>
<span class="line"><span style="color:#A6ACCD;">watchEffect第一次执行是在DOM挂载前执行的，所以如果你想在第一次执行时拿到DOM元</span></span>
<span class="line"><span style="color:#A6ACCD;">素</span></span>
<span class="line"><span style="color:#A6ACCD;">需要传入第二个参数，第二个参数是一个对象，让其flush属性的值为post即可</span></span>
<span class="line"><span style="color:#A6ACCD;">toRefs</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">对reactive进行解构后就失去了响应式的效果，因为reactive返回的是一个Proxy对象</span></span>
<span class="line"><span style="color:#A6ACCD;">对Proxy对象进行解构，拿到的是纯净的值，所以没有了响应式的效果</span></span>
<span class="line"><span style="color:#A6ACCD;">如果想要对reactive进行解构，需要对其包裹一个toRefs</span></span>
<span class="line"><span style="color:#A6ACCD;">这么做相当于为reactive中的每一个值包裹了一个ref</span></span>
<span class="line"><span style="color:#A6ACCD;">等等</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="_3-6-vue3中的watch和watcheffect有什么区别" tabindex="-1">3.6 Vue3中的watch和watchEffect有什么区别？ <a class="header-anchor" href="#_3-6-vue3中的watch和watcheffect有什么区别" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">watch和watchEffect都用用来侦听响应式数据的变化，watch可以侦听指定的源，默认第一次不会</span></span>
<span class="line"><span style="color:#A6ACCD;">执行，watchEffect虽不能指定侦听的源，但是会自动收集依赖，并默认会先执行一次。</span></span>
<span class="line"><span style="color:#A6ACCD;">watch</span></span>
<span class="line"><span style="color:#A6ACCD;">watch可以监听单个数据源，也可以监听多个数据源</span></span>
<span class="line"><span style="color:#A6ACCD;">watch是懒执行，第一次是不会执行的，除非你为其提供第三个参数中的immediate属性为</span></span>
<span class="line"><span style="color:#A6ACCD;">true</span></span>
<span class="line"><span style="color:#A6ACCD;">watch只有等到监听的数据源发生了变化后，才会执行第二个参数（回调）</span></span>
<span class="line"><span style="color:#A6ACCD;">watch可以获取监听数据源的前后变化的值</span></span>
<span class="line"><span style="color:#A6ACCD;">侦听多个数据源的时候，第一个参数是数组类型</span></span>
<span class="line"><span style="color:#A6ACCD;">watchEffect</span></span>
<span class="line"><span style="color:#A6ACCD;">watchEffect会自动收集依赖，收集的依赖是第一个参数，也就是回调函数中有哪些东⻄是加</span></span>
<span class="line"><span style="color:#A6ACCD;">入响应式的</span></span>
<span class="line"><span style="color:#A6ACCD;">如果这个值加入了响应式就会被收集起来，当被收集的值发生了变化，就会重新执行这个回</span></span>
<span class="line"><span style="color:#A6ACCD;">调函数</span></span>
<span class="line"><span style="color:#A6ACCD;">watchEffect第一次执行是在DOM挂载前执行的，所以如果你想在第一次执行时拿到DOM元</span></span>
<span class="line"><span style="color:#A6ACCD;">素</span></span>
<span class="line"><span style="color:#A6ACCD;">需要传入第二个参数，第二个参数是一个对象，让其flush属性的值为post即可</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="_3-7-说说vue3中script-setup语法糖常⻅用法" tabindex="-1">3.7 说说Vue3中script setup语法糖常⻅用法？ <a class="header-anchor" href="#_3-7-说说vue3中script-setup语法糖常⻅用法" aria-hidden="true">#</a></h3><p>script setup 是在单文件组件中使用 Composition API 的编译时语法糖，相比与之前的setup函数写 法，它具有更多的优势：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">更少的样板内容，更简洁的代码。</span></span>
<span class="line"><span style="color:#A6ACCD;">能够使用纯 TypeScript 声明 props 和抛出事件。</span></span>
<span class="line"><span style="color:#A6ACCD;">更好的运行时性能 (其模板会被编译成与其同一作用域的渲染函数，没有任何的中间代理)。</span></span>
<span class="line"><span style="color:#A6ACCD;">更好的 IDE 类型推断性能 (减少语言服务器从代码中抽离类型的工作)。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>1.script setup</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">当使用 script setup 的时候，任何在 script setup 声明的顶层绑定都能在模板中直接使用</span></span>
<span class="line"><span style="color:#A6ACCD;">声明的顶层绑定：包括变量，函数声明，以及 import 引入的内容</span></span>
<span class="line"><span style="color:#A6ACCD;">响应式数据需要通过ref、reactive来创建</span></span>
<span class="line"><span style="color:#A6ACCD;">在script setup中导入的组件可以直接使用</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>2.defineProps</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">在script setup语法糖中必须使用 defineProps API来声明props，它具备完整的类型推断并且在</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;script setup&gt; 中是直接可用的（不需要额外导入）。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>3.defineEmits</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">hash history</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">有 # 号 没有 # 号</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">能够兼容到IE8 只能兼容到IE</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">实际的url之前使用哈希字符，这部分url不会</span></span>
<span class="line"><span style="color:#A6ACCD;">发送到服务器，不需要在服务器层面上进行任</span></span>
<span class="line"><span style="color:#A6ACCD;">何处理</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h4 id="每访问一个⻚面都需要服务器进行路由匹配生成" tabindex="-1">每访问一个⻚面都需要服务器进行路由匹配生成 <a class="header-anchor" href="#每访问一个⻚面都需要服务器进行路由匹配生成" aria-hidden="true">#</a></h4><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">html 文件再发送响应给浏览器，消耗服务器大</span></span>
<span class="line"><span style="color:#A6ACCD;">量资源</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">刷新不会存在 404 问题 浏览器直接访问嵌套路由时，会报 404 问题。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">不需要服务器任何配置 需要在服务器配置一个回调路由</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">在script setup语法糖中必须使用 defineEmits API来声明 emits，它具备完整的类型推断并且在</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;script setup&gt; 中是直接可用的（不需要额外导入）。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>4.defineExpose</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">获取组件的实例可以通过ref来获取，接着组件挂载完成后可通过value拿到组件实例。</span></span>
<span class="line"><span style="color:#A6ACCD;">当拿到组件实例后，默认是不可以访问这个实例中的方法和属性，因为默认没暴露任何方法和属</span></span>
<span class="line"><span style="color:#A6ACCD;">性。</span></span>
<span class="line"><span style="color:#A6ACCD;">因此在Vue3组件中可以用defineExpose API来暴露方法和属性给外部访问。</span></span>
<span class="line"><span style="color:#A6ACCD;">defineExpose 也是不需要导入，直接使用即可</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h2 id="_4-vue-rouer路由" tabindex="-1">4. Vue Rouer路由 <a class="header-anchor" href="#_4-vue-rouer路由" aria-hidden="true">#</a></h2><h3 id="_4-1-vue-router路由的两种模式" tabindex="-1">4.1 vue-router路由的两种模式 <a class="header-anchor" href="#_4-1-vue-router路由的两种模式" aria-hidden="true">#</a></h3><p>vue-router中默认使用的是hash模式</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">1. hash模式，带#。如：&quot;http://localhost:8080/#/page&quot;。改变hash，浏览器本身不会有任何请求服</span></span>
<span class="line"><span style="color:#A6ACCD;">   务器动作。</span></span>
<span class="line"><span style="color:#A6ACCD;">2. history模式，不带#， 如：&quot;&lt;http://localhost:8080/page&quot;，路径没有#。基于HTML5的</span></span>
<span class="line"><span style="color:#A6ACCD;">   pushState、replaceState实现。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="_4-2-路由跳转时如何传递数据" tabindex="-1">4.2 路由跳转时如何传递数据？ <a class="header-anchor" href="#_4-2-路由跳转时如何传递数据" aria-hidden="true">#</a></h3><h4 id="动态路由" tabindex="-1">动态路由 <a class="header-anchor" href="#动态路由" aria-hidden="true">#</a></h4><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">path: /user/:id</span></span>
<span class="line"><span style="color:#A6ACCD;">获取动态路由的值的方式</span></span>
<span class="line"><span style="color:#A6ACCD;">在template中，直接通过 $route.params获取值</span></span>
<span class="line"><span style="color:#A6ACCD;">在created中，通过 this.$route.params获取值</span></span>
<span class="line"><span style="color:#A6ACCD;">在setup中，使用 vue-router库提供的一个hook useRoute</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">该Hook会返回一个Route对象，对象中保存着当前路由相关的值</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>query参数:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">通过query的方式来传递参数</span></span>
<span class="line"><span style="color:#A6ACCD;">在界面中通过 $route.query 来获取参数</span></span>
<span class="line"><span style="color:#A6ACCD;">在created中，通过 this.$route.query获取值</span></span>
<span class="line"><span style="color:#A6ACCD;">在setup，使用 vue-router库提供的一个hook useRoute 来获取</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="_4-3-什么是路由守卫-路由守卫有什么作用" tabindex="-1">4.3 什么是路由守卫？路由守卫有什么作用？ <a class="header-anchor" href="#_4-3-什么是路由守卫-路由守卫有什么作用" aria-hidden="true">#</a></h3><h4 id="什么是路由守卫" tabindex="-1">什么是路由守卫： <a class="header-anchor" href="#什么是路由守卫" aria-hidden="true">#</a></h4><p>vue-router 提供的路由(导航)守卫主要用来通过跳转或取消的方式守卫导航。有很多种方式植入路由导 航中：全局的，单个路由独享的，或者组件级的。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">全局导航钩子</span></span>
<span class="line"><span style="color:#A6ACCD;">router.beforeEach(to,from,next)</span></span>
<span class="line"><span style="color:#A6ACCD;">router.afterEach(to,from)</span></span>
<span class="line"><span style="color:#A6ACCD;">....</span></span>
<span class="line"><span style="color:#A6ACCD;">组件内的钩子</span></span>
<span class="line"><span style="color:#A6ACCD;">beforeRouteEnter (to, from, next)</span></span>
<span class="line"><span style="color:#A6ACCD;">beforeRouteUpdate (to, from, next)</span></span>
<span class="line"><span style="color:#A6ACCD;">beforeRouteLeave (to, from, next)</span></span>
<span class="line"><span style="color:#A6ACCD;">....</span></span>
<span class="line"><span style="color:#A6ACCD;">单独路由独享组件</span></span>
<span class="line"><span style="color:#A6ACCD;">beforeEnter: (to, from, next)</span></span>
<span class="line"><span style="color:#A6ACCD;">afterEach(to,from)</span></span>
<span class="line"><span style="color:#A6ACCD;">....</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h4 id="路由守卫有什么作用" tabindex="-1">路由守卫有什么作用： <a class="header-anchor" href="#路由守卫有什么作用" aria-hidden="true">#</a></h4><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">可以在进入路由之前进行某些判断，比如，检查token是否存在来判断用户是否已经登录。</span></span>
<span class="line"><span style="color:#A6ACCD;">可以在路由守卫中进行⻚面的权限判断，比如，判断某个用户是否拥有该⻚面的权限。</span></span>
<span class="line"><span style="color:#A6ACCD;">也可以用来记录⻚面的某些信息，比如，记录⻚面的滚动信息等等。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="_4-4-route和router的区别" tabindex="-1">4.4 route和router的区别 <a class="header-anchor" href="#_4-4-route和router的区别" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">route是路由信息对象，在Vue3中通过 useRoute 来获取。</span></span>
<span class="line"><span style="color:#A6ACCD;">包括了path，params，hash，query，fullPath，matched，name等路由信息参数。</span></span>
<span class="line"><span style="color:#A6ACCD;">router是路由实例”对象，在Vue3中通过 useRouter 来获取。</span></span>
<span class="line"><span style="color:#A6ACCD;">包括了路由跳转方法、钩子函数等，比如：push、go、back、addRouter、beforeEnter</span></span>
<span class="line"><span style="color:#A6ACCD;">等。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h2 id="_5-vuex和pinia状态管理" tabindex="-1">5.Vuex和Pinia状态管理 <a class="header-anchor" href="#_5-vuex和pinia状态管理" aria-hidden="true">#</a></h2><h3 id="_5-1-什么是状态管理-什么是单项数据流" tabindex="-1">5.1 什么是状态管理？什么是单项数据流？ <a class="header-anchor" href="#_5-1-什么是状态管理-什么是单项数据流" aria-hidden="true">#</a></h3><h4 id="在开发中-应用程序是需要处理各种各样的数据-这些数据需要保存在应用程序中的某一个位置-对于" tabindex="-1">在开发中，应用程序是需要处理各种各样的数据，这些数据需要保存在应用程序中的某一个位置，对于 <a class="header-anchor" href="#在开发中-应用程序是需要处理各种各样的数据-这些数据需要保存在应用程序中的某一个位置-对于" aria-hidden="true">#</a></h4><h4 id="这些数据的管理就称之为是-状态管理-。以前我们是如何管理应用程序的状态" tabindex="-1">这些数据的管理就称之为是 状态管理 。以前我们是如何管理应用程序的状态？ <a class="header-anchor" href="#这些数据的管理就称之为是-状态管理-。以前我们是如何管理应用程序的状态" aria-hidden="true">#</a></h4><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">在Vue开发中，我们使用组件化的开发方式。而在组件中我们定义的data或在setup中返回的数</span></span>
<span class="line"><span style="color:#A6ACCD;">据，这些数据我们称之为状态（State）。</span></span>
<span class="line"><span style="color:#A6ACCD;">在模块template中我们可以使用这些数据，模块最终会被渲染成DOM，我们称之为View。</span></span>
<span class="line"><span style="color:#A6ACCD;">在模块中我们会产生一些行为事件，处理这些行为事件时，有可能会修改State，这些行为事件我</span></span>
<span class="line"><span style="color:#A6ACCD;">们称之为Actions。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>其实Vue组件内部的数据是以单向数据流的形式来管理数据的。例如，组件的数据定义在State中，接着 在View层使用State中的数据，然后View层会产生一些事件Actions，而这些Actions可能会修改State的 数据，这就是一个单项数据流的概念。</p><h3 id="_5-2-什么是vuex-你使用过-vuex-吗" tabindex="-1">5.2 什么是Vuex？你使用过 Vuex 吗？ <a class="header-anchor" href="#_5-2-什么是vuex-你使用过-vuex-吗" aria-hidden="true">#</a></h3><p><strong>什么是Vuex：</strong></p><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。 “store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变</span></span>
<span class="line"><span style="color:#A6ACCD;">化，那么相应的组件也会相应地得到高效更新。</span></span>
<span class="line"><span style="color:#A6ACCD;">改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟</span></span>
<span class="line"><span style="color:#A6ACCD;">踪每一个状态的变化。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>Vuex包括一下几个核心模块：</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</span></span>
<span class="line"><span style="color:#A6ACCD;">Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到</span></span>
<span class="line"><span style="color:#A6ACCD;">计算属性。</span></span>
<span class="line"><span style="color:#A6ACCD;">Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</span></span>
<span class="line"><span style="color:#A6ACCD;">Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</span></span>
<span class="line"><span style="color:#A6ACCD;">Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="_5-3-在哪些场景中会使用到vuex" tabindex="-1">5.3 在哪些场景中会使用到Vuex？ <a class="header-anchor" href="#_5-3-在哪些场景中会使用到vuex" aria-hidden="true">#</a></h3><p>对于简单的项目，是可以不用使用 Vuex，但是对于比较复杂，组件比较多的大项目就需要使用Vuex 了。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">可用于记录收藏、购物⻋、应用配置信息、用户信息等场景中。</span></span>
<span class="line"><span style="color:#A6ACCD;">可用于记录系统的登录状态、用户权限、部⻔信息、系统配置信息等场景中。</span></span>
<span class="line"><span style="color:#A6ACCD;">可用于记录城市列表数据、全局枚举、当前坐标等场景中。</span></span>
<span class="line"><span style="color:#A6ACCD;">⻚面中的组件件嵌套太深了，导致一层层传递数据变的非常麻烦了，也可以将⻚面数据存到Vuex</span></span>
<span class="line"><span style="color:#A6ACCD;">中。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="_5-4-什么是pinia" tabindex="-1">5.4 什么是Pinia？ <a class="header-anchor" href="#_5-4-什么是pinia" aria-hidden="true">#</a></h3><p><strong>什么是Pinia:</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">Pinia 是 Vue 的存储库，它允许您跨组件/⻚面共享状态。</span></span>
<span class="line"><span style="color:#A6ACCD;">Pinia适用于Vue2和Vue3，并不需要使用 Composition API。</span></span>
<span class="line"><span style="color:#A6ACCD;">Pinia的处理安装之后，它的API也同样适用于SSR的应用程序。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>Pinia几个核心概念：</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">state</span></span>
<span class="line"><span style="color:#A6ACCD;">state是一个选项，这个选项的值需要是一个函数，函数返回一个对象，对象中存储数据</span></span>
<span class="line"><span style="color:#A6ACCD;">在组件中拿到当前的store直接使用即可，store.xxx</span></span>
<span class="line"><span style="color:#A6ACCD;">getters</span></span>
<span class="line"><span style="color:#A6ACCD;">getters也是一个选项，这个选项的值是一个对象，对象中存储着一个个函数，每个函数可以</span></span>
<span class="line"><span style="color:#A6ACCD;">有一个参数state，通过state可以获取到当前store的state</span></span>
<span class="line"><span style="color:#A6ACCD;">除此之外每个函数还可以拿到一个this，这个this就是当前的整个store实例</span></span>
<span class="line"><span style="color:#A6ACCD;">通过这个this，可以想用谁就用谁</span></span>
<span class="line"><span style="color:#A6ACCD;">在组件中使用也是拿到store直接store.xxx即可</span></span>
<span class="line"><span style="color:#A6ACCD;">actions</span></span>
<span class="line"><span style="color:#A6ACCD;">在actions中，主要存放一个个函数，每个函数最主要的工作发送异步请求，获取到数据后直</span></span>
<span class="line"><span style="color:#A6ACCD;">接修改state</span></span>
<span class="line"><span style="color:#A6ACCD;">每个action函数并不像getter函数一样，第一个参数是state，它可以没有参数</span></span>
<span class="line"><span style="color:#A6ACCD;">需要通过this拿到state然后再修改state中的值</span></span>
<span class="line"><span style="color:#A6ACCD;">在组件中拿到store后直接调用即可，store.xxx()</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">如果你在此时传递参数，那么就可以在action中拿到参数</span></span>
<span class="line"><span style="color:#A6ACCD;">没有模块modules的概念。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="_5-5-pinia-和-vuex有什么区别" tabindex="-1">5.5 Pinia 和 Vuex有什么区别？ <a class="header-anchor" href="#_5-5-pinia-和-vuex有什么区别" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">Pinia没有Vuex中的mutations选项，因为mutations的出现解决的问题是让devtools进行状态追踪</span></span>
<span class="line"><span style="color:#A6ACCD;">但是随着技术的发展，Pinia已经解决的这个没有mutation依然可以跟踪状态的问题。</span></span>
<span class="line"><span style="color:#A6ACCD;">Pinia可以在任意组件中拿到store然后直接修改state中的任意值</span></span>
<span class="line"><span style="color:#A6ACCD;">Pinia不再需要Vuex中的modules这样的嵌套结构，取而代之的是可以创建一个个store</span></span>
<span class="line"><span style="color:#A6ACCD;">使用上的区别</span></span>
<span class="line"><span style="color:#A6ACCD;">在Vuex中使用某个state时，需要$store.state.xxx</span></span>
<span class="line"><span style="color:#A6ACCD;">在Pinia中直接拿到store之后store.xxx即可</span></span>
<span class="line"><span style="color:#A6ACCD;">在Vuex中使用某个getter函数时，需要$store.getters.xxx</span></span>
<span class="line"><span style="color:#A6ACCD;">在Pinia中拿到store后，store.xxx即可</span></span>
<span class="line"><span style="color:#A6ACCD;">在Vuex中进行异步请求需要派发action函数</span></span>
<span class="line"><span style="color:#A6ACCD;">在Pinia中拿到store后，直接调用action函数即可</span></span>
<span class="line"><span style="color:#A6ACCD;">......</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h2 id="_6-vue其它问题" tabindex="-1">6.Vue其它问题 <a class="header-anchor" href="#_6-vue其它问题" aria-hidden="true">#</a></h2><h3 id="_6-1-什么是虚拟dom-什么是diff算法" tabindex="-1">6.1 什么是虚拟DOM？什么是diff算法？ <a class="header-anchor" href="#_6-1-什么是虚拟dom-什么是diff算法" aria-hidden="true">#</a></h3><h4 id="什么是虚拟dom" tabindex="-1">什么是虚拟DOM： <a class="header-anchor" href="#什么是虚拟dom" aria-hidden="true">#</a></h4><p>Virtual DOM 本质上是 JavaScript 对象，是真实 DOM 的描述，用一个 JS 对象来描述一个 DOM 节点。</p><p>Virtual DOM 可以看做一棵模拟 DOM 树的 JavaScript 树，其主要是通过 VNode 实现一个无状态的组 件，当组件状态发生更新时，然后触发 Virtual DOM 数据的变化，然后通过 Virtual DOM 和真实 DOM 的比对，再对真实 DOM 更新。可以简单认为 Virtual DOM 是真实 DOM 的缓存。</p><p><strong>虚拟 DOM 的优缺点:</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki has-diff"><code><span class="line"><span style="color:#A6ACCD;">优点：</span></span>
<span class="line"><span style="color:#A6ACCD;">跨平台与分层设计 (主要原因)：虚拟 DOM 本质上是 JavaScript 对象，而真实 DOM 与平台强</span></span>
<span class="line"><span style="color:#A6ACCD;">相关，相比之下虚拟 DOM 带来了分层设计、跨平台以及 SSR 等特性。至于 Virtual DOM 比</span></span>
<span class="line"><span style="color:#A6ACCD;">原生 DOM 谁的性能好，需要 “控制变量法” 才能比较。这是为什么要设计虚拟 DOM 的主要</span></span>
<span class="line"><span style="color:#A6ACCD;">原因。虚拟 DOM 抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的</span></span>
<span class="line"><span style="color:#A6ACCD;">DOM，可以是安卓和 iOS 的原生组件，也可以是小程序，也可以是各种 GUI。</span></span>
<span class="line"><span style="color:#A6ACCD;">以最小的代价更新变化的视图 。整棵 DOM 树实现代价太高，能否只更新变化的部分的视</span></span>
<span class="line"><span style="color:#A6ACCD;">图。虚拟 DOM 能通过 patch 准确地转换为真实 DOM，并且方便进行 diff。</span></span>
<span class="line"><span style="color:#A6ACCD;">保证性能下限 (次要原因)：框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作(分层设</span></span>
<span class="line"><span style="color:#A6ACCD;">计)，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h4 id="的-dom-操作性能要好很多-因此框架的虚拟-dom-至少可以保证在你不需要手动优化的情" tabindex="-1">的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情 <a class="header-anchor" href="#的-dom-操作性能要好很多-因此框架的虚拟-dom-至少可以保证在你不需要手动优化的情" aria-hidden="true">#</a></h4><h4 id="况下-依然可以提供还不错的性能-即保证性能的下限。" tabindex="-1">况下，依然可以提供还不错的性能，即保证性能的下限。 <a class="header-anchor" href="#况下-依然可以提供还不错的性能-即保证性能的下限。" aria-hidden="true">#</a></h4><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki has-diff"><code><span class="line"><span style="color:#A6ACCD;">无需手动操作 DOM ：操作 DOM 慢，js 运行效率高。我们可以将 DOM 对比(diff 操作)放在</span></span>
<span class="line"><span style="color:#A6ACCD;">JS 层，提高效率。我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框</span></span>
<span class="line"><span style="color:#A6ACCD;">架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开</span></span>
<span class="line"><span style="color:#A6ACCD;">发效率。</span></span>
<span class="line"><span style="color:#A6ACCD;">组件的高度抽象化 ：Vue.2x 引入 VirtualDOM 把渲染过程抽象化，从而使得组件的抽象能力</span></span>
<span class="line"><span style="color:#A6ACCD;">也得到提升，并且可以适配 DOM 以外的渲染目标。不再依赖 HTML 解析器进行模版解析，</span></span>
<span class="line"><span style="color:#A6ACCD;">可以进行更多的 AOT 工作提高运行时效率：通过模版 AOT 编译，Vue 的运行时体积可以进</span></span>
<span class="line"><span style="color:#A6ACCD;">一步压缩，运行时效率可以进一步提升。 Virtual DOM 的优势不在于单次的操作，而是在大</span></span>
<span class="line"><span style="color:#A6ACCD;">量、频繁的数据更新下，能够对视图进行合理、高效的更新 。为了实现高效的 DOM 操作，</span></span>
<span class="line"><span style="color:#A6ACCD;">一套高效的虚拟 DOM diff 算法显得很有必要.</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h4 id="缺点-1" tabindex="-1">缺点: <a class="header-anchor" href="#缺点-1" aria-hidden="true">#</a></h4><h4 id="无法进行极致优化-虽然虚拟-dom-合理的优化-足以应对绝大部分应用的性能需求-但" tabindex="-1">无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但 <a class="header-anchor" href="#无法进行极致优化-虽然虚拟-dom-合理的优化-足以应对绝大部分应用的性能需求-但" aria-hidden="true">#</a></h4><h4 id="在一些性能要求极高的应用中虚拟-dom-无法进行针对性的极致优化。" tabindex="-1">在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。 <a class="header-anchor" href="#在一些性能要求极高的应用中虚拟-dom-无法进行针对性的极致优化。" aria-hidden="true">#</a></h4><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">虽然 Vue 能够保证触发更新的组件最小化，但在单个组件内部依然需要遍历该组件的整个</span></span>
<span class="line"><span style="color:#A6ACCD;">Virtual DOM 树。</span></span>
<span class="line"><span style="color:#A6ACCD;">在一些组件整个模版内只有少量动态节点的情况下，这些遍历都是性能的浪费。</span></span>
<span class="line"><span style="color:#A6ACCD;">传统 Virtual DOM 的性能跟模版大小正相关，跟动态节点的数量无关。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>什么是diff算法：</strong></p><p>diff 算法是一种通过同层的树节点进行比较的高效算法。diff 整体策略为：深度优先，同层比较。</p><p>新旧两个 VNode 节点的左右头尾两侧均有一个变量标识，在遍历过程中这几个变量都会向中间靠拢。 当 oldStartIdx &lt;= oldEndIdx 或者 newStartIdx &lt;= newEndIdx 时结束循环。在遍历中，如果</p><p>存在 key，并且满足 sameVnode，会将该 DOM 节点进行复用(只通过移动节点顺序)，否则则会创建一 个新的 DOM 节点。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">oldStartVnode、oldEndVnode 与 newStartVnode、newEndVnode 两两比较共有四种比较方法：</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><ol><li>当新旧子树的两个开始节点或新旧子树的两个结束节点相同时 当新旧 VNode 节点的 start 或者 end 满足 sameVnode 时，也就是 sameVnode(oldStartVnode, newStartVnode) 或者 sameVnode(oldEndVnode, newEndVnode) 表示为 true，直接将该 VNode 节点进行 patchVnode 即可（保留）。</li><li>当旧子树的开始节点与新子树的结束节点相同时 当 oldStartVnode 与 newEndVnode 满足 sameVnode，即 sameVnode(oldStartVnode, newEndVnode)。这时候说明 oldStartVnode 已经跑到了 oldEndVnode 后面去了，进行 patchVnode 的同时还需要将真实 DOM 节点移动到 oldEndVnode 的后面。</li><li>当旧子树的结束节点与新子树的开始节点相同时 如果 oldEndVnode 与 newStartVnode 满足 sameVnode，即 sameVnode(oldEndVnode, newStartVnode)。这说明 oldEndVnode 跑到了 oldStartVnode 的前面，进行 patchVnode 的同 时真实的 DOM 节点移动到了 oldStartVnode 的前面。</li><li>当旧子树中没有新子树中的节点，会将新节点插入到 oldStartVnode 前</li></ol><p>如果以上情况均不符合，进入 key 的比较：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">oldKeyToIdx ：一个哈希表，存放旧节点的 key 与节点的映射关系；如果没有 oldKeyToIdx 则会</span></span>
<span class="line"><span style="color:#A6ACCD;">通过 createKeyToOldIdx 会得到一个 oldKeyToIdx，里面存放旧节点的 key 与节点的映射关系，</span></span>
<span class="line"><span style="color:#A6ACCD;">只不过这个 key 是 index 序列。从 oldKeyToIdx 这个哈希表中可以找到与新节点是否有相同 key</span></span>
<span class="line"><span style="color:#A6ACCD;">的旧节点，如果同时满足 sameVnode，patchVnode 的同时会将这个真实 DOM（elmToMove）</span></span>
<span class="line"><span style="color:#A6ACCD;">移动到 oldStartVnode 对应的真实 DOM 的前面。</span></span>
<span class="line"><span style="color:#A6ACCD;">idxInOld ：拿新节点的 key 去 oldKeyToIdx 找是否有与旧节点相同的节点，即旧节点中是否有与</span></span>
<span class="line"><span style="color:#A6ACCD;">新节点 key 相同的节点，没有就通过 findIdxInOld 遍历旧节点并通过 sameVnode 判断是否有相</span></span>
<span class="line"><span style="color:#A6ACCD;">同节点，有返回索引。</span></span>
<span class="line"><span style="color:#A6ACCD;">idxInOld 不存在，即新节点在旧节点中都没有找到，说明这是一个之前没有的新节点，需要</span></span>
<span class="line"><span style="color:#A6ACCD;">通过 createElm 创建新节点</span></span>
<span class="line"><span style="color:#A6ACCD;">idxInOld 存在，则进一步通过 sameVnode(vnodeToMove, newStartVnode) 判断是否是同</span></span>
<span class="line"><span style="color:#A6ACCD;">一节点</span></span>
<span class="line"><span style="color:#A6ACCD;">是同一节点，则通过 patchVnode 更新，并移动节点</span></span>
<span class="line"><span style="color:#A6ACCD;">不是同一节点，即相同的 key 不同的元素，则通过 createElm 创建新节点</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>先 oldStartVnode、oldEndVnode 与 newStartVnode、newEndVnode 两两通过 sameVnode 进行 4</p><p>次比较，若成立，则通过 patchVnode 更新节点内容，并移动节点位置。若不成立，再进一步比较 key，idxInOld 判断新节点是否被旧节点复用了。idxInOld 不存在，说明旧节点没有复用新节点，新节 点需要 createElm 创建；idxInOld 存在，说明新节点有被复用的可能性，为什么这么说，因为此时我们 只知道节点的 key 相同，是否是通过简单的 <strong>通过移动节点位置达到复用的目的</strong> ，还是说通过创建节点进 行原地复用或就地修改，需要进一步通过 sameVnode(vnodeToMove, newStartVnode) 判断是否是同 一节点。是同一节点，则直接通过 patchVnode 更新，并移动节点；否则，虽然有相同的 key 但是不同 的元素，则通过 createElm 创建新节点，就地修改。从这一点我们就可以思考出为什么 v-for 的时候 要加上 key？为什么这个 key 不建议 index 来标识？</p><h3 id="_6-2-vue2-和-vue3-响应性原理" tabindex="-1">6.2 Vue2 和 Vue3 响应性原理 <a class="header-anchor" href="#_6-2-vue2-和-vue3-响应性原理" aria-hidden="true">#</a></h3><p>Vue.js 2.0 采用数据劫持并结合了发布者-订阅者模式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><p>官网的描述：<a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noreferrer">https://cn.vuejs.org/v2/guide/reactivity.html</a></p><p>Vue.js 3.0放弃了Object.defineProperty API，而使用了更快的Proxy API。Proxy 是在 ES6 中引入，它 允许你拦截对该对象的任何交互，也可以避免 Vue 早期版本中存在的一些响应性问题。</p><p>官网描述：<a href="https://v3.cn.vuejs.org/guide/reactivity.html" target="_blank" rel="noreferrer">https://v3.cn.vuejs.org/guide/reactivity.html</a></p><h3 id="_6-3-nexttick-方法的实现原理" tabindex="-1">6.3 nextTick 方法的实现原理 <a class="header-anchor" href="#_6-3-nexttick-方法的实现原理" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">当调用nexttick函数时，nexttick内部会将回调函数使用Promise来包裹，目的是将该回调函数加入</span></span>
<span class="line"><span style="color:#A6ACCD;">到微任务队列中。</span></span>
<span class="line"><span style="color:#A6ACCD;">在队列中的任务都是先进先出的，所以当执行完主程序的代码之后就会执行微任务队列中nexttick</span></span>
<span class="line"><span style="color:#A6ACCD;">的回调函数，那这个过程就称为一次tick。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">所以nexttick的回调函数将会推迟到下一个 DOM 更新周期之后执行。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="_6-4-proxy-与-object-defineproperty-优劣对比" tabindex="-1">6.4 Proxy 与 Object.defineProperty 优劣对比 <a class="header-anchor" href="#_6-4-proxy-与-object-defineproperty-优劣对比" aria-hidden="true">#</a></h3><p><strong>Proxy 的优势如下:</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">Object.defineProperty 只能劫持对象的属性，而 Proxy 是直接代理对象。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>由于 Object.defineProperty 只能对属性进行劫持，需要遍历对象的每个属性，如果属性值也是对象， 则需要深度遍历。而 Proxy 直接代理对象，不需要遍历操作。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">Object.defineProperty 对新增属性需要手动进行 Observe。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>由于 Object.defineProperty 劫持的是对象的属性，所以新增属性时，需要重新遍历对象，对其新增属 性再使用 Object.defineProperty 进行劫持。</p><p>也正是因为这个原因，使用 Vue 给 data 中的数组或对象新增属性时，需要使用 vm.$set 才能保证新增 的属性也是响应式的。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">Proxy支持 13 种拦截操作，这是 defineProperty 所不具有的。</span></span>
<span class="line"><span style="color:#A6ACCD;">get(target, propKey, receiver)：拦截对象属性的读取，比如 proxy.foo 和proxy[&#39;foo&#39;]。</span></span>
<span class="line"><span style="color:#A6ACCD;">set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v 或</span></span>
<span class="line"><span style="color:#A6ACCD;">proxy[&#39;foo&#39;] = v，返回一个布尔值。</span></span>
<span class="line"><span style="color:#A6ACCD;">has(target, propKey)：拦截 propKey in proxy 的操作，返回一个布尔值。</span></span>
<span class="line"><span style="color:#A6ACCD;">deleteProperty(target, propKey)：拦截 delete proxy[propKey] 的操作，返回一个布尔值。</span></span>
<span class="line"><span style="color:#A6ACCD;">ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、</span></span>
<span class="line"><span style="color:#A6ACCD;">Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数</span></span>
<span class="line"><span style="color:#A6ACCD;">组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys() 的返回结果仅包括目标</span></span>
<span class="line"><span style="color:#A6ACCD;">对象自身的可遍历属性。</span></span>
<span class="line"><span style="color:#A6ACCD;">getOwnPropertyDescriptor(target, propKey)：拦截</span></span>
<span class="line"><span style="color:#A6ACCD;">Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</span></span>
<span class="line"><span style="color:#A6ACCD;">defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey,</span></span>
<span class="line"><span style="color:#A6ACCD;">propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</span></span>
<span class="line"><span style="color:#A6ACCD;">preventExtensions(target)：拦截 Object.preventExtensions(proxy)，返回一个布尔值。</span></span>
<span class="line"><span style="color:#A6ACCD;">getPrototypeOf(target)：拦截 Object.getPrototypeOf(proxy)，返回一个对象。</span></span>
<span class="line"><span style="color:#A6ACCD;">isExtensible(target)：拦截 Object.isExtensible(proxy)，返回一个布尔值。</span></span>
<span class="line"><span style="color:#A6ACCD;">setPrototypeOf(target, proto)：拦截 Object.setPrototypeOf(proxy, proto)，返回一个布尔</span></span>
<span class="line"><span style="color:#A6ACCD;">值。如果目标对象是函数，那么还有两种额外操作可以拦截。</span></span>
<span class="line"><span style="color:#A6ACCD;">apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、</span></span>
<span class="line"><span style="color:#A6ACCD;">proxy.call(object, ...args)、proxy.apply(...)。</span></span>
<span class="line"><span style="color:#A6ACCD;">construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new</span></span>
<span class="line"><span style="color:#A6ACCD;">proxy(...args)。</span></span>
<span class="line"><span style="color:#A6ACCD;">新标准性能红利</span></span>
<span class="line"><span style="color:#A6ACCD;">Proxy 作为新标准，从⻓远来看，JS 引擎会继续优化 Proxy，但 getter 和 setter 基本不会再有针</span></span>
<span class="line"><span style="color:#A6ACCD;">对性优化。</span></span>
<span class="line"><span style="color:#A6ACCD;">Proxy 兼容性差</span></span>
<span class="line"><span style="color:#A6ACCD;">Proxy 对于 IE 浏览器来说简直是灾难。 并且目前并没有一个完整支持 Proxy 所有拦截方法的</span></span>
<span class="line"><span style="color:#A6ACCD;">Polyfill 方案，有一个 Google 编写的 proxy-polyfill 也只支持了 get、set、apply、construct 四种</span></span>
<span class="line"><span style="color:#A6ACCD;">拦截，可以支持到 IE9+ 和 Safari 6+。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>Object.defineProperty 的优势如下:</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">兼容性好，支持 IE9。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>最后总结：</strong></p><ol><li>Object.defineProperty 并非不能监控数组下标的变化，Vue2.x 中无法通过数组索引来实现响应式 数据的自动更新是 Vue 本身的设计导致的，不是 defineProperty 的锅。</li><li>Object.defineProperty 和 Proxy 本质差别是，defineProperty 只能对属性进行劫持，所以出现了 需要递归遍历，新增属性需要手动 Observe 的问题。</li><li>Proxy 作为新标准，浏览器厂商势必会对其进行持续优化，但它的兼容性也是块硬伤，并且目前还 没有完整的 polyfill 方案。</li></ol><h3 id="_6-5-使用过-vue-ssr-吗-说说-ssr" tabindex="-1">6.5 使用过 Vue SSR 吗？说说 SSR？ <a class="header-anchor" href="#_6-5-使用过-vue-ssr-吗-说说-ssr" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成</span></span>
<span class="line"><span style="color:#A6ACCD;">DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送</span></span>
<span class="line"><span style="color:#A6ACCD;">到浏览器，最后将这些静态标记&quot;激活&quot;为客户端上完全可交互的应用程序。</span></span>
<span class="line"><span style="color:#A6ACCD;">即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务</span></span>
<span class="line"><span style="color:#A6ACCD;">端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>服务端渲染 SSR 的优缺点如下：</strong></p><p><strong>（ 1 ）服务端渲染的优点：</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">更好的 SEO： 因为 SPA ⻚面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步</span></span>
<span class="line"><span style="color:#A6ACCD;">完成后再抓取⻚面内容，所以在 SPA 中是抓取不到⻚面通过 Ajax 获取到的内容；而 SSR 是直接由</span></span>
<span class="line"><span style="color:#A6ACCD;">服务端返回已经渲染好的⻚面（数据已经包含在⻚面中），所以搜索引擎爬取工具可以抓取渲染好</span></span>
<span class="line"><span style="color:#A6ACCD;">的⻚面；</span></span>
<span class="line"><span style="color:#A6ACCD;">更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才</span></span>
<span class="line"><span style="color:#A6ACCD;">开始进行⻚面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由</span></span>
<span class="line"><span style="color:#A6ACCD;">服务端渲染好⻚面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到</span></span>
<span class="line"><span style="color:#A6ACCD;">达时间；</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>（2) 服务端渲染的缺点：</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致</span></span>
<span class="line"><span style="color:#A6ACCD;">一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文</span></span>
<span class="line"><span style="color:#A6ACCD;">件服务器上的完全静态单⻚面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js</span></span>
<span class="line"><span style="color:#A6ACCD;">server 运行环境；</span></span>
<span class="line"><span style="color:#A6ACCD;">更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更</span></span>
<span class="line"><span style="color:#A6ACCD;">加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic )</span></span>
<span class="line"><span style="color:#A6ACCD;">下使用，请准备相应的服务器负载，并明智地采用缓存策略。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="_6-6-你有对-vue-项目进行哪些优化" tabindex="-1">6.6 你有对 Vue 项目进行哪些优化？ <a class="header-anchor" href="#_6-6-你有对-vue-项目进行哪些优化" aria-hidden="true">#</a></h3><h4 id="_1-代码层面的优化" tabindex="-1">（ 1 ）代码层面的优化 <a class="header-anchor" href="#_1-代码层面的优化" aria-hidden="true">#</a></h4><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">v-if 和 v-show 区分使用场景</span></span>
<span class="line"><span style="color:#A6ACCD;">computed 和 watch 区分使用场景</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</span></span>
<span class="line"><span style="color:#A6ACCD;">⻓列表性能优化</span></span>
<span class="line"><span style="color:#A6ACCD;">事件的销毁</span></span>
<span class="line"><span style="color:#A6ACCD;">图片资源懒加载</span></span>
<span class="line"><span style="color:#A6ACCD;">路由懒加载</span></span>
<span class="line"><span style="color:#A6ACCD;">第三方插件的按需引入</span></span>
<span class="line"><span style="color:#A6ACCD;">优化无限列表性能</span></span>
<span class="line"><span style="color:#A6ACCD;">服务端渲染 SSR or 预渲染</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>（ 2 ）打包层面的优化</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">Webpack 对图片进行压缩</span></span>
<span class="line"><span style="color:#A6ACCD;">减少 ES6 转为 ES5 的冗余代码</span></span>
<span class="line"><span style="color:#A6ACCD;">提取公共代码</span></span>
<span class="line"><span style="color:#A6ACCD;">模板预编译</span></span>
<span class="line"><span style="color:#A6ACCD;">提取组件的 CSS</span></span>
<span class="line"><span style="color:#A6ACCD;">优化 SourceMap</span></span>
<span class="line"><span style="color:#A6ACCD;">构建结果输出分析</span></span>
<span class="line"><span style="color:#A6ACCD;">Vue 项目的编译优化</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>（ 3 ）其它的优化</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">开启 gzip 压缩</span></span>
<span class="line"><span style="color:#A6ACCD;">浏览器缓存</span></span>
<span class="line"><span style="color:#A6ACCD;">CDN 的使用</span></span>
<span class="line"><span style="color:#A6ACCD;">使用 Chrome Performance 查找性能瓶颈</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="_6-7-如何实现vue首屏加载优化的" tabindex="-1">6.7 如何实现Vue首屏加载优化的 <a class="header-anchor" href="#_6-7-如何实现vue首屏加载优化的" aria-hidden="true">#</a></h3><ol><li>把不常改变的库放到index.html中，并接入CDN提速</li><li>Vue路由的懒加载，Vue组件尽量不要全局引入</li><li>使用轻量级的工具库</li><li>减少首⻚的资源请求数，减少资源的大小</li><li>避免使用大图，图片使用懒加载</li><li>等等</li></ol><h3 id="_6-8-vue3-0-里为什么要用-proxy-api替代-defineproperty-api" tabindex="-1">6.8 Vue3.0 里为什么要用 Proxy API替代 defineProperty API <a class="header-anchor" href="#_6-8-vue3-0-里为什么要用-proxy-api替代-defineproperty-api" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">defineProperty API 的局限性最大原因是它只能针对对象的属性做监听。</span></span>
<span class="line"><span style="color:#A6ACCD;">Vue2.x中的响应式实现正是基于Object.defineProperty来实现，对 data 中的属性做了遍历 + 递</span></span>
<span class="line"><span style="color:#A6ACCD;">归，为每个属性设置了 getter、setter。这也就是为什么 Vue 只能对 data 中预定义过的属性做出</span></span>
<span class="line"><span style="color:#A6ACCD;">响应的原因。</span></span>
<span class="line"><span style="color:#A6ACCD;">Proxy API监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作， 这就完全可以代</span></span>
<span class="line"><span style="color:#A6ACCD;">理所有属性，将带来很大的性能提升和更优的代码。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦</span></span>
<span class="line"><span style="color:#A6ACCD;">截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</span></span>
<span class="line"><span style="color:#A6ACCD;">Proxy响应式是惰性的。</span></span>
<span class="line"><span style="color:#A6ACCD;">在 Vue.js 2.x 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的变化，就需要递归遍历这</span></span>
<span class="line"><span style="color:#A6ACCD;">个对象，执行 Object.defineProperty 把每一层对象数据都变成响应式的，这无疑会有很大的性能</span></span>
<span class="line"><span style="color:#A6ACCD;">消耗。</span></span>
<span class="line"><span style="color:#A6ACCD;">在 Vue.js 3.0 中，使用 Proxy API 并不能监听到对象内部深层次的属性变化，因此它的处理方式是</span></span>
<span class="line"><span style="color:#A6ACCD;">在 getter 中去递归响应式，这样的好处是真正访问到的内部属性才会变成响应式，简单的可以说</span></span>
<span class="line"><span style="color:#A6ACCD;">是按需实现响应式，减少性能消耗。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h2 id="_7-axios网络请求库" tabindex="-1">7. Axios网络请求库 <a class="header-anchor" href="#_7-axios网络请求库" aria-hidden="true">#</a></h2><h3 id="_7-1-axios是什么-怎么使用它-怎么解决跨域" tabindex="-1">7.1 Axios是什么？怎么使用它，怎么解决跨域？ <a class="header-anchor" href="#_7-1-axios是什么-怎么使用它-怎么解决跨域" aria-hidden="true">#</a></h3><p><strong>Axios是什么？</strong></p><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。前端最流行的 ajax 请求库， react/vue 官方都推荐使用 axios 发 ajax 请求</p><p><strong>Axios特点:</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">基于 promise 的异步 ajax 请求库，支持promise所有的API</span></span>
<span class="line"><span style="color:#A6ACCD;">浏览器端/node 端都可以使用，浏览器中创建XMLHttpRequests</span></span>
<span class="line"><span style="color:#A6ACCD;">支持请求／响应拦截器</span></span>
<span class="line"><span style="color:#A6ACCD;">支持请求取消</span></span>
<span class="line"><span style="color:#A6ACCD;">JSON数据的自动转换</span></span>
<span class="line"><span style="color:#A6ACCD;">可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON类型的数据</span></span>
<span class="line"><span style="color:#A6ACCD;">批量发送多个请求</span></span>
<span class="line"><span style="color:#A6ACCD;">安全性更高，客户端支持防御 XSRF。</span></span>
<span class="line"><span style="color:#A6ACCD;">就是让你的每个请求都带一个从cookie中拿到的key, 根据浏览器同源策略，假冒的网站是拿不到你</span></span>
<span class="line"><span style="color:#A6ACCD;">cookie中得key的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，</span></span>
<span class="line"><span style="color:#A6ACCD;">从而采取正确的策略。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>常用语法：</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">axios(config): 通用/最本质的发任意类型请求的方式</span></span>
<span class="line"><span style="color:#A6ACCD;">axios.request(config): 等同于 axios(config)</span></span>
<span class="line"><span style="color:#A6ACCD;">axios.get(url[, config]): 发 get 请求</span></span>
<span class="line"><span style="color:#A6ACCD;">axios.post(url[, data, config]): 发 post 请求</span></span>
<span class="line"><span style="color:#A6ACCD;">axios.defaults.xxx: 请求的默认全局配置</span></span>
<span class="line"><span style="color:#A6ACCD;">axios.interceptors.request.use(): 添加请求拦截器</span></span>
<span class="line"><span style="color:#A6ACCD;">axios.interceptors.response.use(): 添加响应拦截器</span></span>
<span class="line"><span style="color:#A6ACCD;">axios.create([config]): 创建一个新的 axios(它没有下面的功能)</span></span>
<span class="line"><span style="color:#A6ACCD;">axios.CancelToken(): 用于创建取消请求的 token 对象</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">axios.all(promises): 用于批量执行多个异步请求</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>开发环境中解决跨域：</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">方式一：在vue.config.js中的devServer选项中的proxy中配置反向代理</span></span>
<span class="line"><span style="color:#A6ACCD;">方式二：在vite.config.js中的server选项中的proxy中配置反向代理</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">方式三：直接后端开发人员配置cors</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>部署的时候解决跨域：</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">方式一：直接后端开发人员配置cors</span></span>
<span class="line"><span style="color:#A6ACCD;">方式二：反向代理，比如：nginx 服务器的反向代理。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h2 id="_8-vue-vs-react" tabindex="-1">8. Vue VS React <a class="header-anchor" href="#_8-vue-vs-react" aria-hidden="true">#</a></h2><h3 id="_8-1-vue和react有什么不同-使用场景分别是什么" tabindex="-1">8.1 Vue和React有什么不同？使用场景分别是什么？ <a class="header-anchor" href="#_8-1-vue和react有什么不同-使用场景分别是什么" aria-hidden="true">#</a></h3><p><strong>Vue和React的区别：</strong></p><p>虽然Vue和React两者在定位上有一些交集，但差异也是很明显的。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">Vue 使用的是 web 开发者更熟悉的模板与特性 。</span></span>
<span class="line"><span style="color:#A6ACCD;">Vue的API跟传统web开发者熟悉的模板契合度更高，比如Vue的单文件组件是以模板</span></span>
<span class="line"><span style="color:#A6ACCD;">+JavaScript+CSS的组合模式呈现，它跟web现有的HTML、JavaScript、CSS能够更好地配合。</span></span>
<span class="line"><span style="color:#A6ACCD;">React 的特色在于函数式编程的理念和丰富的技术选型 。</span></span>
<span class="line"><span style="color:#A6ACCD;">Vue 比起 React 更容易被前端工程师接受，这是一个直观的感受；React 则更容易吸引在 FP 上持</span></span>
<span class="line"><span style="color:#A6ACCD;">续走下去的开发者。</span></span>
<span class="line"><span style="color:#A6ACCD;">从 使用习惯和思维模式 上考虑，对于一个没有任何Vue和React基础的web开发者来说， Vue会更</span></span>
<span class="line"><span style="color:#A6ACCD;">友好，更符合他的思维模式。</span></span>
<span class="line"><span style="color:#A6ACCD;">React对于拥有函数式编程背景的开发者以及一些并不是以web为主要开发平台的开发人员而言，</span></span>
<span class="line"><span style="color:#A6ACCD;">React更容易接受。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">这并不意味着他们不能接受Vue，Vue和React之间的差异对他们来说就没有web开发者那么明显。</span></span>
<span class="line"><span style="color:#A6ACCD;">可以说， Vue更加注重web开发者的习惯 。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>各自使用场景：</strong></p><p>React：适合构建大型应用程序，其函数编程让React开发应用时非常的灵活，并且React对TS支持非常 的友好，也有非常大的生态系统。</p><p>Vue：适合使用模板搭建小而快的应用；适合简单、对灵活度要求没那么高的应用。自从Vue3出来后， 对TS支持也越来越友好，生态系统也在慢慢的完善起来了。</p></div></div></main><!--[--><!--]--><footer class="VPDocFooter" data-v-998ff9da data-v-6f96f21a><!----><div class="prev-next" data-v-6f96f21a><div class="pager" data-v-6f96f21a><a class="pager-link prev" href="/blog/menus/testOne.html" data-v-6f96f21a><span class="desc" data-v-6f96f21a>Previous page</span><span class="title" data-v-6f96f21a>js高级面试题</span></a></div><div class="has-prev pager" data-v-6f96f21a><!----></div></div></footer><!--[--><!--]--></div></div></div></div></div><!----><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"guide_button.md\":\"63ce44ce\",\"guide_loading.md\":\"85277e7b\",\"index.md\":\"38732985\",\"jstop_promise.md\":\"1ea7c99e\",\"jstop_protypechain.md\":\"a00a620b\",\"jstop_setmap.md\":\"6cd2131e\",\"menus_testone.md\":\"5a0bcd3b\",\"menus_testtwo.md\":\"68ebdeba\"}")</script>
    <script type="module" async src="/blog/assets/app.5bf900bc.js"></script>
    
  </body>
</html>